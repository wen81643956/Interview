# Interview

## 知识点

-   [ ] this 问题
-   [ ] 闭包
-   [ ] 继承
-   [ ] 原型链
-   [ ] 跨域通信
-   [ ] MVVM
-   [ ] reflow, repaint
-   [ ] 事件冒泡, 事件捕获
-   [ ] Promise
-   [ ] Generator
-   [ ] Decorator
-   [x] call, apply, bind
-   [ ] event loop (microtask, macrotask)
-   [ ] 模块机制 (CommonJs, AMD, es 模块, UMD)
-   [ ] ajax, fetch
-   [ ] 单页应用路由原理
-   [ ] webpack 打包优化
-   [ ] 深拷贝
-   [ ] 数组去重
-   [ ] 数组排序
-   [ ] 安全问题 (XSS, CSRF)
-   [ ] url 到页面展现的过程
-   [ ] http 状态码
-   [ ] 浏览器缓存机制
-   [ ] BFC (块级格式化上下文)
-   [ ] 清除浮动
-   [ ] 居中问题
-   [ ] 函数柯里化 (高阶函数)
-   [ ] 观察者模式, 迭代器模式
-   [ ] 页面性能优化
-   [ ] 内存泄漏
-   [x] new 操作符
-   [ ] null 和 undefined 区别
-   [x] 变量提升
-   [ ] 自定义事件
-   [ ] debounce throttle 的实现
-   [ ] BEM 规范
-   [ ] 垃圾回收机制
-   [ ] 创建对象的方式
-   [x] 作用域 (执行上下文)
-   [ ] 判断数据类型
-   [ ] new String('a') 和 'a' 的区别（包装类型）/ 包装对象
-   [ ] 箭头函数
-   [ ] 堆栈
-   [ ] redux 原理
-   [ ] 写一个 redux 中间件
-   [ ] 为什么要使用 redux, redux 解决了什么问题
-   [ ] 虚拟 dom
-   [ ] diff 算法
-   [ ] react16 新特性
-   [ ] react context
-   [ ] 尾递归优化
-   [ ] TypeSript 和 JavaScript 有什么区别
-   [ ] 说说 TypeSript 的优缺点
-   [ ] 什么样的项目适合使用 TypeScript
-   [ ] TypeScript 里面 type 和 interface 的区别, 分别在什么场景下适用
-   [ ] 三方库如果没有类型文件, 你会怎么解决这个问题
-   [ ] React 高阶组件实现方式
-   [ ] 如何设计并写好 React 组件
-   [ ] React 容器组件和木偶组件区别, 为什么要划分它们
-   [ ] React 核心思想
-   [ ] React 组件 key 属性的作用是什么
-   [ ] 受控组件和非受控组件
-   [ ] renderProps 模式和高阶组件对比
-   [ ] 类组件和函数式组件区别, 分别在什么场景下适用
-   [ ] setState 之后 React 做了什么
-   [ ] redux 和 mobx 对比
-   [ ] 应该在哪个生命周期发起 ajax
-   [ ] 如何使用 immutablejs 优化 React 组件性能
-   [ ] 为什么要使用 immutablejs
-   [ ] immutable 思想
-   [ ] immutableJs 结构共享
-   [ ] React 的合成事件, 为什么 React 要做自己的事件系统
-   [x] JSX 原理
-   [ ] setState 的几种使用方式及区别
-   [ ] redux 有什么缺点
-   [ ] 单向数据流思想, 为什么要用单向数据流
-   [ ] 为什么虚拟 DOM 可以提高性能
-   [ ] React-router 实现原理
-   [ ] 什么时候下 key 可以使用 index
-   [ ] refs 的几种方式及区别
-   [ ] React fiber 架构
-   [ ] React 与 Vue 的比较
-   [ ] React.PureComponent
